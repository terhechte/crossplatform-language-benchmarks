import os, sys, platform, time, subprocess, csv, pickle
from os.path import join, abspath
from shutil import copyfile
from collections import OrderedDict
import ConfigParser

CONFIG_FILE = "bench.cfg"

class BenchConfig:
    class SectionWrapper:
        def __init__(self, name, config):
            self.name = name
            self.config = config
        def __getattr__(self, key):
            if self.name == "active":
                return self.config.getboolean(self.name, key)
            else:
                return self.config.get(self.name, key)
    def __init__(self, config_file):
        self.config = ConfigParser.ConfigParser()
        self.config.read(abspath(config_file))
        self.sections = {
            "general": BenchConfig.SectionWrapper("general", self.config),
            "active": BenchConfig.SectionWrapper("active", self.config),
            "titles": BenchConfig.SectionWrapper("titles", self.config),
            "directories": BenchConfig.SectionWrapper("directories", self.config)
        }

    def __getattr__(self, key):
        return self.sections[key]

class BuildSystem:
    # The name of this system
    name = None
    # This is an input parameter
    infile = None
    # This is generated by the build system
    outfile = None
    # This is an input parameter
    source_directory = None
    # This is an input parameter
    out_directory = None
    def __init__(self, infile, source_directory, out_directory):
        self.infile = infile
        self.source_directory = source_directory
        self.out_directory = out_directory
    def clean(self): pass
    def prebuild(self): pass
    def build_cwd(self): return os.path.curdir
    def build(self): pass
    def postbuild(self): pass
    def run(self):
        return abspath(join(self.out_directory, self.outfile))
    def execute(self, command):
        p = subprocess.Popen(command.split(), stderr=subprocess.STDOUT, cwd=self.build_cwd())
        p.wait()

class SwiftBuildSystem (BuildSystem):
    name = "Swift"
    def build(self):
        self.outfile = self.infile.replace(".swift", "")
        return "%s -O %s -o %s" % (config.general.binary_swift, abspath(join(self.source_directory, self.infile)), abspath(join(self.out_directory, self.outfile)))

class RustBuildSystem (BuildSystem):
    name = "Rust"
    def build(self):
        self.outfile = self.infile.replace(".rs", "")
        return "%s -O %s -o %s" % (config.general.binary_rust, abspath(join(self.source_directory, self.infile)), abspath(join(self.out_directory, self.outfile)))

class KotlinBuildSystem (BuildSystem):
    name = "Kotlin"
    def build(self):
        outfile = self.infile.replace(".kt", "")
        self.outfile = outfile + ".kexe"
        return "%s -opt %s -o %s" % (config.general.binary_kotlin, abspath(join(self.source_directory, self.infile)), abspath(join(self.out_directory, self.outfile)))

class CBuildSystem (BuildSystem):
    name = "C"
    def build(self):
        self.outfile = self.infile.replace(".c", "")
        return "%s -O2 %s -o %s" % (config.general.binary_clang, abspath(join(self.source_directory, self.infile)), abspath(join(self.out_directory, self.outfile)))

class CPPBuildSystem (BuildSystem):
    name = "C++"
    def build(self):
        self.outfile = self.infile.replace(".cpp", "")
        return "%s -std=c++17 -O2 %s -o %s" % (config.general.binary_clangcpp, abspath(join(self.source_directory, self.infile)), abspath(join(self.out_directory, self.outfile)))

class CargoBuildSystem (BuildSystem):
    name = "Rust"
    def perform_in_cargo(self, command, ret = False):
        if ret:
            return command
        else:
            self.execute(command)

    def build_cwd(self):
        return abspath(join(self.source_directory, self.infile))

    def clean(self):
        self.perform_in_cargo("%s clean" % (config.general.binary_cargo))

    def prebuild(self):
        self.perform_in_cargo("%s build-deps" % (config.general.binary_cargo))

    def build(self):
        self.outfile = self.infile
        return self.perform_in_cargo("%s build --release" % (config.general.binary_cargo), ret = True)

    def postbuild(self):
        source_path = abspath(join(self.source_directory, self.infile, join("target", "release"), self.outfile))
        target_path = abspath(join(self.out_directory, self.infile))
        os.system("cp %s %s" % (source_path, target_path))

class GradleBuildSystem (BuildSystem):
    name = "Kotlin"
    def perform_in_gradle(self, command, ret = False):
        if ret:
            return command
        else:
            self.execute(command)

    def gradle_bin(self):
        return abspath(join(self.source_directory, self.infile, "gradlew"))

    def build_cwd(self):
        return abspath(join(self.source_directory, self.infile))

    def clean(self):
        print self.gradle_bin()
        self.perform_in_gradle("%s clean" % (self.gradle_bin(),))

    def build(self):
        self.outfile = self.infile
        return self.perform_in_gradle("%s compileReleaseKotlinNative" % (self.gradle_bin()), ret = True)

    def postbuild(self):
        source_path = abspath(join(self.source_directory, self.infile, 
            join("build", "exe", "main", "release"), 
            "%s.kexe" % (self.outfile,)))
        target_path = abspath(join(self.out_directory, self.infile))
        os.system("cp %s %s" % (source_path, target_path))

class BenchResult:
    name = ""
    language = ""
    command = ""
    is_compile = False
    is_fail = False
    real = 0.0
    user = 0.0
    sys = 0.0
    resident_set_size = 0
    page_reclaims = 0
    children = []

    def __str__(self):
        return "%s: real: %f, user: %f, sys: %f, max resident set size: %i" % (self.name, self.real, self.user, self.sys, self.resident_set_size)

    def merge(self, items):
        self.children = items
        c = 0
        fail = False
        for item in items:
            if item.is_fail == True: 
                fail = True
                continue
            self.real += item.real
            self.user += item.user
            self.sys += item.sys
            self.resident_set_size += item.resident_set_size
            self.page_reclaims += item.page_reclaims
            c += 1
        self.fail = fail
        if c == 0: return
        self.real /= c
        self.user /= c
        self.sys /= c
        self.resident_set_size /= c
        self.page_reclaims /= c

class Bencher:
    benches = OrderedDict()
    languages = set()
    count = None

    def __init__(self, count):
        self.count = count

    def bench_for_system(self, command, result):
        operating_system = platform.system()
        if operating_system == "Linux":
            return self.bench_for_linux(command, result)
        elif operating_system == "Darwin":
            return self.bench_for_darwin(command, result)
        else:
            print "Unknown Platform", operating_system
            sys.exit()

    def bench_for_darwin(self, command, result):
        cmd = ["time", "-l"] + command.split()

        def split_load(line, result):
            """parse the bench results into real, user, sys and apply to result"""
            comps = line.split()
            result.real = float(comps[0])
            result.user = float(comps[2])
            result.sys = float(comps[4])

        def parse_fn(output):
            for line in output.split("\n"):
                if line.find("real") >= 0 or line.find("user") >= 0 or line.find("sys") >= 0:
                    split_load(line, result)
                if line.find("maximum resident set size") >= 0:
                    result.resident_set_size = int(line.split()[0])
                if line.find("page reclaims") >= 0:
                    result.page_reclaims = int(line.split()[0])
        return (cmd, parse_fn)

    def bench_for_linux(self, command, result):
        fmt = "xbench-real:%e\nxbench-user:%U\nxbench-sys:%S\nxbench-residentset:%M\nxbench-reclaims:%t\n"
        cmd = ["/usr/bin/time", "-f", fmt] + command.split()
        def parse_fn(output):
            for line in output.split("\n"):
		if line.find("xbench-user:") != -1: result.user = float(line.split(":")[1].strip())
		if line.find("xbench-sys:") != -1: result.sys = float(line.split(":")[1].strip())
		if line.find("xbench-real:") != -1: result.real = float(line.split(":")[1].strip())
		if line.find("xbench-residentset:") != -1: result.resident_set_size = float(line.split(":")[1].strip())
		if line.find("xbench-reclaims:") != -1: result.page_reclaims = float(line.split(":")[1].strip())
        return (cmd, parse_fn)


    def bench_command(self, command, cwd):
        """run a command and return the timing"""
        print "\t: %s" % (command,)
        result = BenchResult()
        result.command = command
        (popen_command, parse_fn) = self.bench_for_system(command, result)
        # Make sure we don't run too long
        begin = time.time()
        process = subprocess.Popen(popen_command, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, cwd=cwd)
        while True:
            if process.poll() != None:
                break
            if (time.time() - begin) > int(config.general.bench_max_time):
                print "Executing %s took too long. Quitting." % (command,)
                fail_result = BenchResult()
                fail_result.is_fail = True
                return fail_result
        output = process.stdout.read()
        parse_fn(output)
        return result

    def multi_bench_command(self, command, cwd):
        new = BenchResult()
        new.merge([self.bench_command(command, cwd) for x in range(0, self.count)])
        return new

    def bench_entry(self, name, entry, perform_clean = True):
        # If benching this language is disabled, stop
        if not entry.name in config.general.active_languages:
            print "Unsupported language", entry.name
            return
        if perform_clean:
            entry.clean()
            entry.prebuild()
        command = entry.build()
        print "Benching Compile: ", name, entry.name
        compile_bench = self.bench_command(command, entry.build_cwd())
        compile_bench.name = name
        compile_bench.language = entry.name
        compile_bench.is_compile = True
        lst = None
        key = "Compile: " + name
        try:
            lst = self.benches[key]
        except KeyError:
            lst = []
            self.benches[key] = lst
        lst.append(compile_bench)
        entry.postbuild()
        # if the compiling failed, we can't execute it
        bench = None
        if compile_bench.is_fail == True:
            bench = BenchResult()
            bench.is_fail = True
        else:
            print "Benching: ", name, entry.name
            run_command = entry.run()
            bench = self.multi_bench_command(run_command, abspath(config.directories.resource_directory))
        bench.name = name
        bench.language = entry.name
        self.languages.add(entry.name)
        try:
            lst = self.benches[name]
        except KeyError:
            lst = []
            self.benches[name] = lst
        lst.append(bench)

    def write_bench_pickle(self, folder):
        with open(abspath(join(folder, version_info() + ".pickle")), "w") as picklefile:
            pickle.dump(self.benches, picklefile)

    def write_bench_csv(self, folder):
        fieldnames = ["Benchmark"] + list(self.languages)
        with open(abspath(join(folder, version_info() + ".csv")), "w") as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            for bench_name in self.benches.keys():
                language_benches = self.benches[bench_name]
                values = {"Benchmark": bench_name}
                for language_bench in language_benches:
                    values[language_bench.language] = language_bench.real
                writer.writerow(values)

def version_info():
  def detect_version():
    linux = platform.linux_distribution()
    macos = platform.mac_ver()
    win = platform.win32_ver()
    if len(linux[0]) > 0: return linux
    elif len(macos[0]) > 0: return macos
    elif len(win[0]) > 0: return win
    else: return (sys.platform, ('', '', ''), platform.architecture()[0])
  version = detect_version()
  return "%s-%s-%s" % (sys.platform, version[0], version[-1])

def build_system_factory(in_dir, out_dir):
    def fn(infile):
        language = infile.split(".")[-1]
        if language == "swift": return SwiftBuildSystem(infile, in_dir, out_dir)
        elif language == "rs": return RustBuildSystem(infile, in_dir, out_dir)
        elif language == "kt": return KotlinBuildSystem(infile, in_dir, out_dir)
        elif language == "c": return CBuildSystem(infile, in_dir, out_dir)
        elif language == "cpp": return CPPBuildSystem(infile, in_dir, out_dir)
    return fn

def clear_builds(out_dir):
    for f in os.listdir(out_dir):
        if f == "empty": continue
        os.remove(abspath(join(out_dir, f)))

def make_benches():
    clear_builds(config.directories.build_directory)
    builder = build_system_factory(config.directories.source_directory, config.directories.build_directory)
    bencher = Bencher(int(config.general.iteration_count))
    if config.active.primes_functional:
        title = config.titles.primes_functional_title
        bencher.bench_entry(title, builder("prime_swift.swift"))
        bencher.bench_entry(title, builder("prime_rust.rs"))
        bencher.bench_entry(title, builder("prime_kotlin.kt"))
        bencher.bench_entry(title, builder("prime_cpp.cpp"))
    if config.active.strings_functional:
        title = config.titles.strings_functional_title
        bencher.bench_entry(title, builder("strings_functional_swift.swift"))
        bencher.bench_entry(title, builder("strings_functional_rust.rs"))
        bencher.bench_entry(title, builder("strings_functional_kotlin.kt"))
        bencher.bench_entry(title, builder("strings_functional_cpp.cpp"))
    if config.active.strings_imperative:
        title = config.titles.strings_imperative_title
        bencher.bench_entry(title, builder("strings_imperative_swift.swift"))
        bencher.bench_entry(title, builder("strings_imperative_rust.rs"))
        bencher.bench_entry(title, builder("strings_imperative_kotlin.kt"))
        bencher.bench_entry(title, builder("strings_imperative_cpp.cpp"))
    if config.active.chunks_functional:
        title = config.titles.chunks_functional_title
        bencher.bench_entry(title, builder("chunks_functional_swift.swift"))
        bencher.bench_entry(title, builder("chunks_functional_rust.rs"))
        bencher.bench_entry(title, builder("chunks_functional_kotlin.kt"))
        bencher.bench_entry(title, builder("chunks_imperative_c.c"))
    if config.active.chunks_imperative:
        title = config.titles.chunks_imperative_title
        bencher.bench_entry(title, builder("chunks_imperative_swift.swift"))
        bencher.bench_entry(title, builder("chunks_imperative_rust.rs"))
        bencher.bench_entry(title, builder("chunks_imperative_kotlin.kt"))
        bencher.bench_entry(title, builder("chunks_imperative_c.c"))
    if config.active.json:
        title = config.titles.json_title
        bencher.bench_entry(title, builder("json_swift.swift"))
        bencher.bench_entry(title, CargoBuildSystem("json_rust", config.directories.source_directory, config.directories.build_directory))
        bencher.bench_entry(title + "_PB", CargoBuildSystem("json_rust", config.directories.source_directory, config.directories.build_directory), perform_clean = False)
        bencher.bench_entry(title, GradleBuildSystem("json_kotlin", config.directories.source_directory, config.directories.build_directory))
        bencher.bench_entry(title + "_PB", GradleBuildSystem("json_kotlin", config.directories.source_directory, config.directories.build_directory), perform_clean = False)

    bencher.write_bench_csv(config.directories.bench_csv_directory)
    bencher.write_bench_pickle(config.directories.bench_csv_directory)

def make_charts():
    """Goes through all the csv files, and renders them as markdown tables. Returns all."""
    def make_chart(filepath):
        name = os.path.splitext(os.path.basename(filepath))[0]
        output = []
        with open(filepath, "r") as csvfile:
            reader = csv.DictReader(csvfile)
            fields = reader.fieldnames
            output.append(" | ".join(fields))
            longest = max(map(lambda x: len(x), fields))
            output.append(" | ".join([longest * "-" for x in range(0, len(fields))]))
            for row in reader:
                line = []
                for field in fields:
                    try:
                        line.append(str(round(float(row[field]), 2)))
                    except ValueError:
                        line.append(row[field])
                output.append(" | ".join(line))
        return "# " + name + "\n" + "\n".join(["| %s |" % (x,) for x in output])
    charts = []
    for f in os.listdir(abspath(config.directories.bench_csv_directory)):
        if f[-3:] != "csv":continue
        charts.append(make_chart(abspath(join(config.directories.bench_csv_directory, f))))
    print "\n\n".join(charts)

def make_html_charts(filename):
    """Goes through all the csv files, and renders them as html charts. Terrible Code."""
    colors = [
            #["Navy", "#001f3f", "#000e2e"],
            ["Blue", "#0074D9", "#0063c8"],
            ["Aqua", "#7FDBFF", "#6ecaee"],
            ["Maroon", "#85144b", "#74033a"],
            ["Olive", "#3D9970", "#2c8860"],
            ["Teal", "#39CCCC", "#28bbbC"],
            ["Fuchsia", "#F012BE", "#e001ac"]]
    tmpl = """
    <html><style>
    * {
  font-family: -apple-system, "avenir next", avenir, roboto, noto, ubuntu, "helvetica neue", helvetica, arial, sans-serif;
  font-size: 15px;
    }
h3 {
font-size: 24px;
font-weight: 300;
}
    div.chart {
    margin: 15px;
    padding: 15px;
    background-color: #fafafa;
    border: 1px solid #ddd;
    border-radius: 3px;
    }
.chart div.bar {
  text-align: right;
  padding: 3px;
  margin: 1px;
  height: 20px;
  border-width: 3px;
  border: 3px solid #e9b900;
  border-radius: 3px;
}
.row-title {
height: 50px;
padding-right: 10px;
}
.bar {
float: left;
}
table {
}
span.time {
  font-weight: medium;
  font-size: 15px;
  padding-top: 7px;
  padding-left: 3px;
float: left;
}
span.alert {
font-weight: bold;
background-color: red;
padding: 4px;
border: 2px solid white;
display: block;
}
</style><body>%s</body></html>"""
    name = os.path.splitext(os.path.basename(filename))[0]

    max_width = 700
    chart_title_width = 60
    chart_sec_width = 70

    def html_chart(name, field_values, max_value, unit="s", round_fn=round):
        # sort the fields
        field_values = sorted(field_values, key=lambda k: k[0])
        output = ""
        output += "<div class='chart'><h3>%s</h3>" % (name,)
        output += '<table class="chart" style="width: %spx">' % (max_width,)
        cnt = 0
        for (field, val) in field_values:
            # None val means wasn't measured
            if val == None: continue
            color = colors[cnt]
            cnt += 1
            output += "<tr>"
            output += '<td class="row-title" style="width: %spx" vertical-align="middle">%s</td>' % (chart_title_width, field)
            if val == "FAIL":
                output += '<td style="width: 100%%"><span class="alert">Kill after 10min</span></td></tr>'
                continue
            calc_percent = val / max_value
            calc_width = (max_width - (chart_title_width + chart_sec_width)) * calc_percent
            color_block = "background-color: %s; border-color: %s" % (color[1], color[2])
            output += '<td style="width: 100%%"><div class="bar" style="%s; width: %spx;"></div><span class="time">%s %s</span></td>' % (color_block, int(calc_width), round_fn(val, 2), unit)
            output += "</tr>"
        output += '</table>'
        output += '</div>'
        return output

    with open(filename, "r") as csvfile:
        reader = csv.DictReader(csvfile)
        fields = reader.fieldnames
        # we need some extra space
        charts_output = "<div style='width: %spx' class='charts'><h2>%s</h2>" % (max_width + chart_sec_width, filename,)

        # build a compile_total and a run total
        # all those values are percentage (0-1)
        # ["rust"] = [0.1, 0.5]
        # ["c"] = [0.1, 0.5]
        compile_total = {}
        run_total = {}

        for row in reader:
            # calculate the max value
            xmax = 0.0
            field_values = []
            for field in fields:
                if field == "Benchmark": continue
                value = row[field]
                # 0.0 means it failed
                if value == "0.0":
                    field_values.append((field, "FAIL"))
                    continue
                if len(value) == 0:
                    field_values.append((field, None))
                    continue
                s = float(value)
                if s > xmax: 
                    xmax = s
                field_values.append((field, s))
            # calculate totals
            for (k, v) in field_values:
                # totals ignore C, C++ as they have not enough tests
                if k in ["C", "C++"]: continue
                try:
                    s = float(v) / xmax
                    if row["Benchmark"].startswith("Compile:"):
                        if not compile_total.has_key(k): compile_total[k] = []
                        compile_total[k].append(s)
                    else:
                        if not run_total.has_key(k): run_total[k] = []
                        run_total[k].append(s)
                except:
                    pass
            charts_output += html_chart(row["Benchmark"], field_values, xmax)
        def chart_with_total(name, total):
            field_values = { (k, sum(v)/len(v) * 100) for k, v in total.iteritems() }
            return html_chart(name, field_values, 100, unit="%", round_fn = lambda x, y: round(x, 0))
        charts_output += chart_with_total("Compile Total %", compile_total)
        charts_output += chart_with_total("Run Total %", run_total)
        print tmpl % (charts_output,)

def usage():
    print """
    Usage:
      python ./bench.py [task]
        Tasks:
         "charts": Will render all charts in 'benches/' to markdown and print them
         "html_charts path/to/bench.csv": Will render all charts in 'benches/' to markdown and print them
         "bench": Will run all activated benchmarks, and write to the 'benches/' directory
    """
    sys.exit()

config = BenchConfig(CONFIG_FILE)

if __name__ == "__main__":
    command = ""
    try:
        command = sys.argv[1]
    except IndexError:
        pass
    if command == "charts":
        make_charts()
    elif command == "bench":
        make_benches()
    elif command == "html_charts":
        try:
            make_html_charts(sys.argv[2])
        except IndexError:
            usage()
    else:
        usage()
